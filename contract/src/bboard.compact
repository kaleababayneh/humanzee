pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

enum Status { ACTIVE, REJECTED, PASSED }

// Proposal structure for governance voting
export struct Proposal {
  id: Uint<64>;
  description: Opaque<"string">;
  proposer: Bytes<32>;
  deadline_timestamp: Uint<64>;
  votes_for: Uint<64>;
  votes_against: Uint<64>;
  executed: Status;
}

// Individual vote record
export struct Vote {
  proposal_id: Uint<64>;
  voter_hash: Bytes<32>;
  vote_type: Boolean; // true = for, false = against
  timestamp: Uint<64>;
}

// Comment on a proposal
export struct Comment {
  proposal_id: Uint<64>;
  commenter_hash: Bytes<32>;
  comment: Opaque<"string">;
  timestamp: Uint<64>;
}

// Signature structure for authenticating actions
export struct Signature {
  pk: CurvePoint;
  R: CurvePoint;
  s: Field;
  nonce: Bytes<32>; 
}

// Authority credential signature (authority signs user hashes)
export struct AuthorityCredential {
  user_hash: Bytes<32>;
  liveliness: Field;
  authority_signature: Signature;
}

// Internal structures for cryptographic operations
struct ChallengeInput {
  b0: Field;
  b1: Field;
  b2: Bytes<32>;
}

struct NonceInput {
  b0: Bytes<15>;
  b1: Bytes<32>;
}

struct MessageWithNonce {
  b0: Bytes<32>;
  b1: Bytes<32>;
}

// Ledger state - what's stored on-chain
export ledger proposal: Proposal;
export ledger votes: List<Vote>;
export ledger comments: List<Comment>;
export ledger voter_registry: Set<Bytes<32>>; // Track who has voted to prevent double voting
export ledger sequence: Counter;
export ledger used_nonces: Set<Bytes<32>>;
export ledger used_credentials: Set<Bytes<32>>; // Track used user hashes to prevent reuse
export ledger authority_pk: CurvePoint;
export ledger min_liveliness: Field;

// Witnesses for private data
witness localSecretKey(): Bytes<32>;

constructor(_min_liveliness : Uint<64>, _proposer: Bytes<32>, description: Opaque<"string">, deadline_in_ms: Uint<64>) {
  // Initialize with the deployer's public key as the authority
  const sk = disclose(localSecretKey());
  authority_pk = derive_pk(sk);
  min_liveliness = disclose(_min_liveliness);
  
  
  proposal = Proposal {
    id: sequence as Uint<64>,
    description: disclose(description),
    proposer: disclose(_proposer),
    deadline_timestamp: disclose(deadline_in_ms),
    votes_for: 0 as Uint<64>,
    votes_against: 0 as Uint<64>,
    executed: Status.ACTIVE
  };
}

// Derive public key from private key
export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {
  assert(sk_bytes != default<Bytes<32>>, "Private key cannot be zero");
  const sk_bytes15: Bytes<15> = slice<15>(sk_bytes, 0);
  const sk_field: Field = sk_bytes15 as Field;
  const pk: CurvePoint = ecMulGenerator(sk_field);
  return pk;
}

// Authority signs a user hash to create a credential
export circuit issueCredential(user_hash: Bytes<32>): Signature {
  // Only the authority can issue credentials
  const sk_bytes: Bytes<32> = disclose(localSecretKey());
  assert(sk_bytes != default<Bytes<32>>, "Private key cannot be zero");
  
  const authority_pk_derived = derive_pk(sk_bytes);
  assert(authority_pk_derived == authority_pk, "Only authority can issue credentials");
  
  // Generate deterministic nonce from user_hash and authority key
  const sk_bytes15: Bytes<15> = slice<15>(sk_bytes, 0);
  const nonce_input: NonceInput = NonceInput { b0: sk_bytes15, b1: user_hash };
  const current_nonce: Bytes<32> = persistentHash<NonceInput>(nonce_input);
  
  // Hash user_hash with nonce
  const msg_with_nonce: MessageWithNonce = MessageWithNonce{ b0: user_hash, b1: current_nonce };
  const msg_hash: Bytes<32> = persistentHash<MessageWithNonce>(msg_with_nonce);
  
  // Generate signature components
  const sk_field: Field = sk_bytes15 as Field;
  
  // Deterministic k from (sk, msg_hash)
  const k_nonce_input: NonceInput = NonceInput { b0: sk_bytes15, b1: msg_hash };
  const k_hash: Bytes<32> = persistentHash<NonceInput>(k_nonce_input);
  const k_bytes15: Bytes<15> = slice<15>(k_hash, 0);
  const k_field: Field = k_bytes15 as Field;
  assert(k_field != 0, "Nonce cannot be zero");
  
  // R = k * G
  const R: CurvePoint = ecMulGenerator(k_field);
  
  // Challenge: c = H(R || pk || msg_hash)
  const c_bytes: ChallengeInput = ChallengeInput {
    b0: R.x,
    b1: authority_pk.x,
    b2: msg_hash
  };
  
  const c_hash: Bytes<32> = persistentHash<ChallengeInput>(c_bytes);
  const c_bytes15: Bytes<15> = slice<15>(c_hash, 0);
  const c_field: Field = c_bytes15 as Field;
  assert(c_field != 0, "Challenge cannot be zero");
  
  // s = k + c * sk
  const s: Field = k_field + (c_field * sk_field);
    
  return Signature { pk: authority_pk, R: R, s: s, nonce: current_nonce };
}

// Verify authority credential (authority signature over user hash)
export circuit verify_credential(credential: AuthorityCredential): [] {
  const {user_hash, liveliness, authority_signature} = disclose(credential);
  assert(liveliness as Uint<8> > min_liveliness as Uint<8>, "credential is not lively");
  const {pk, R, s, nonce} = authority_signature;
  
  assert(pk == authority_pk, "Credential not signed by authority");
  //assert(!used_nonces.member(nonce), "Nonce already used: replay attack detected");
  //assert(!used_credentials.member(user_hash), "User credential already used");
  
  const msg_with_nonce: MessageWithNonce = MessageWithNonce{ b0: user_hash, b1: nonce };
  const msg_hash: Bytes<32> = persistentHash<MessageWithNonce>(msg_with_nonce);
  
  const R_x: Field = R.x;
  const authority_x: Field = authority_pk.x;
  
  assert(R_x != 0, "R.x cannot be zero");
  assert(authority_x != 0, "authority_pk.x cannot be zero");
  
  const c_bytes: ChallengeInput = ChallengeInput {
    b0: R_x,
    b1: authority_x,  
    b2: msg_hash  
  };
  
  const c_hash: Bytes<32> = persistentHash<ChallengeInput>(c_bytes);
  const c_bytes15: Bytes<15> = slice<15>(c_hash, 0);
  assert(c_bytes15 != default<Bytes<15>>, "Challenge bytes cannot be zero");
  const c_field: Field = c_bytes15 as Field;
  assert(c_field != 0, "Challenge cannot be zero");

  const lhs: CurvePoint = ecMulGenerator(s);
  const c_pk: CurvePoint = ecMul(pk, c_field);
  const rhs: CurvePoint = ecAdd(R, c_pk);

  assert(lhs == rhs, "Authority signature verification failed");
  used_nonces.insert(nonce);
  used_credentials.insert(user_hash);
}

// Get authority public key
export circuit getAuthorityPk(): CurvePoint {
  return authority_pk;
}

export circuit getSequence(): Uint<64> {
  return sequence as Uint<64>;
}

// Vote for a proposal
export circuit voteFor(credential: AuthorityCredential): [] {
  // Verify the authority credential
  verify_credential(credential);
  
  // Check that proposal is still active and voting is open
  assert(proposal.executed == Status.ACTIVE, "Proposal is not active");
  //assert(blockTimeLte(proposal.deadline_timestamp), "Voting deadline has passed");
  
  // Prevent double voting
  const voter_hash = disclose(credential.user_hash);
  assert(!voter_registry.member(voter_hash), "User has already voted");
  
  // Record the vote
  const new_vote = Vote {
    proposal_id: proposal.id,
    voter_hash: voter_hash,
    vote_type: true, // true = for
    timestamp: 0 as Uint<64> // Block time will be automatically recorded
  };
  
  votes.pushFront(new_vote);
  voter_registry.insert(voter_hash);
  
  // Update proposal vote count by recreating the struct
  proposal = Proposal {
    id: proposal.id,
    description: proposal.description,
    proposer: proposal.proposer,
    deadline_timestamp: proposal.deadline_timestamp,
    votes_for: proposal.votes_for + 1 as Uint<64>,
    votes_against: proposal.votes_against,
    executed: proposal.executed
  };
}

// Vote against a proposal
export circuit voteAgainst(credential: AuthorityCredential): [] {
  // Verify the authority credential
  verify_credential(credential);
  
  // Check that proposal is still active and voting is open
  assert(proposal.executed == Status.ACTIVE, "Proposal is not active");
  //assert(blockTimeLte(proposal.deadline_timestamp), "Voting deadline has passed");
  
  // Prevent double voting
  const voter_hash = disclose(credential.user_hash);
  assert(!voter_registry.member(voter_hash), "User has already voted");
  
  // Record the vote
  const new_vote = Vote {
    proposal_id: proposal.id,
    voter_hash: voter_hash,
    vote_type: false, // false = against
    timestamp: 0 as Uint<64> // Block time will be automatically recorded
  };
  
  votes.pushFront(new_vote);
  voter_registry.insert(voter_hash);
  
  // Update proposal vote count by recreating the struct
  proposal = Proposal {
    id: proposal.id,
    description: proposal.description,
    proposer: proposal.proposer,
    deadline_timestamp: proposal.deadline_timestamp,
    votes_for: proposal.votes_for,
    votes_against: proposal.votes_against + 1 as Uint<64>,
    executed: proposal.executed
  };
}

// Add a comment to the proposal
export circuit commentOnProposal(commentText: Opaque<"string">, credential: AuthorityCredential): [] {
  // Verify the authority credential
  verify_credential(credential);
  
  // Check that proposal is still active (allow comments even after voting ends)
  assert(proposal.executed != Status.REJECTED, "Cannot comment on rejected proposals");
  
  // Create the comment
  const new_comment = Comment {
    proposal_id: proposal.id,
    commenter_hash: disclose(credential.user_hash),
    comment: disclose(commentText),
    timestamp: 0 as Uint<64> // Block time will be automatically recorded
  };
  
  comments.pushFront(new_comment);
}

// Execute/finalize the proposal (can only be called by authority)
export circuit executeProposal(): [] {
  // Only the authority can execute proposals
  const sk_bytes: Bytes<32> = disclose(localSecretKey());
  const authority_pk_derived = derive_pk(sk_bytes);
  assert(authority_pk_derived == authority_pk, "Only authority can execute proposals");
  
  // Check that voting deadline has passed
  //assert(blockTimeGt(proposal.deadline_timestamp), "Voting deadline has not passed yet");
  assert(proposal.executed == Status.ACTIVE, "Proposal has already been executed");
  
  // Determine result based on votes
  const new_status =  (proposal.votes_for > proposal.votes_against) ? Status.PASSED : Status.REJECTED;

  
  // Update proposal status by recreating the struct
  proposal = Proposal {
    id: proposal.id,
    description: proposal.description,
    proposer: proposal.proposer,
    deadline_timestamp: proposal.deadline_timestamp,
    votes_for: proposal.votes_for,
    votes_against: proposal.votes_against,
    executed: new_status
  };
}

// Get current proposal status
export circuit getProposal(): Proposal {
  return proposal;
}

// Get total vote count
export circuit getVoteCount(): Uint<64> {
  return votes.length() as Uint<64>;
}

// Get total comment count
export circuit getCommentCount(): Uint<64> {
  return comments.length() as Uint<64>;
}

// Check if a user has voted
export circuit hasUserVoted(userHash: Bytes<32>): Boolean {
  return voter_registry.member(disclose(userHash));
}

// Check if voting is still open
export circuit isVotingOpen(): Boolean {
  return proposal.executed == Status.ACTIVE;// && blockTimeLte(proposal.deadline_timestamp);
}

// Check if proposal has expired (past deadline)
export circuit hasProposalExpired(): Boolean {
  return false;// blockTimeGt(proposal.deadline_timestamp);
}


// Wallet seed: 8dd96c613b92a1ced03ac5e71a039d4447cfe84928864fc38260b28cd30378c2

import { createInterface, type Interface } from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { WebSocket } from 'ws';
// import { webcrypto } from 'crypto';
import {
  type BBoardProviders,
  BBoardAPI,
  utils,
  type BBoardDerivedState,
  type DeployedBBoardContract,
  type PrivateStateId,
  bboardPrivateStateKey,
  type BBoardCircuitKeys,
} from '../../api/src/index';
import { ledger, type Ledger } from '../../contract/src/managed/humanzee/contract/index.cjs';
import {
  type BalancedTransaction,
  createBalancedTx,
  type MidnightProvider,
  type UnbalancedTransaction,
  type WalletProvider,
} from '@midnight-ntwrk/midnight-js-types';
import { type Wallet } from '@midnight-ntwrk/wallet-api';
import * as Rx from 'rxjs';
import { type CoinInfo, nativeToken, Transaction, type TransactionId } from '@midnight-ntwrk/ledger';
import { Transaction as ZswapTransaction } from '@midnight-ntwrk/zswap';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import { type Resource, WalletBuilder } from '@midnight-ntwrk/wallet';
import { indexerPublicDataProvider } from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';
import { httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { type Logger } from 'pino';
import { type Config, StandaloneConfig } from './config.js';
import type { StartedDockerComposeEnvironment, DockerComposeEnvironment } from 'testcontainers';
import { levelPrivateStateProvider } from '@midnight-ntwrk/midnight-js-level-private-state-provider';
import { type ContractAddress } from '@midnight-ntwrk/compact-runtime';
import { toHex, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import { getLedgerNetworkId, getZswapNetworkId } from '@midnight-ntwrk/midnight-js-network-id';

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

/* **********************************************************************
 * getBBoardLedgerState: a helper that queries the current state of
 * the data on the ledger, for a specific bulletin board contract.
 * Note that the Ledger type returned here is not some generic,
 * abstract ledger object, but specifically the type generated by
 * the Compact compiler to correspond to the ledger declaration
 * in the bulletin board contract.
 */

export const getBBoardLedgerState = async (
  providers: BBoardProviders,
  contractAddress: ContractAddress,
): Promise<Ledger | null> => {
  assertIsContractAddress(contractAddress);
  const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
  return contractState != null ? ledger(contractState.data) : null;
};

/* **********************************************************************
 * deployOrJoin: returns a contract, by prompting the user about
 * whether to deploy a new one or join an existing one and then
 * calling the appropriate helper.
 */

const DEPLOY_OR_JOIN_QUESTION = `
You can do one of the following:
  1. Deploy a new voting contract
  2. Join an existing voting contract
  3. Exit
Which would you like to do? `;

const deployOrJoin = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<BBoardAPI | null> => {
  let api: BBoardAPI | null = null;

  while (true) {
    const choice = await rli.question(DEPLOY_OR_JOIN_QUESTION);
    switch (choice) {
      case '1':
        // Prompt for deployment parameters
        const description = await rli.question('Enter proposal description (default: "Default governance proposal"): ') || "Default governance proposal";
        const hoursFromNow = await rli.question('Enter voting deadline hours from now (default: 1): ') || "1";
        const deadlineInSeconds = BigInt(Math.floor(Date.now() / 1000) + parseInt(hoursFromNow) * 3600);
        
        api = await BBoardAPI.deploy(providers, BigInt(50), description, deadlineInSeconds, logger);
        logger.info(`Deployed voting contract at address: ${api.deployedContractAddress}`);
        logger.info(`Proposal: "${description}"`);
        logger.info(`Voting deadline: ${new Date(Number(deadlineInSeconds) * 1000).toISOString()}`);
        return api;
      case '2':
        api = await BBoardAPI.join(providers, await rli.question('What is the contract address (in hex)? '), logger);
        logger.info(`Joined voting contract at address: ${api.deployedContractAddress}`);
        return api;
      case '3':
        logger.info('Exiting...');
        return null;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

/* **********************************************************************
 * displayLedgerState: shows the values of each of the fields declared
 * by the contract to be in the ledger state of the bulletin board.
 */

const displayLedgerState = async (
  providers: BBoardProviders,
  deployedBBoardContract: DeployedBBoardContract,
  logger: Logger,
): Promise<void> => {
  const contractAddress = deployedBBoardContract.deployTxData.public.contractAddress;
  const ledgerState = await getBBoardLedgerState(providers, contractAddress);
  if (ledgerState === null) {
    logger.info(`There is no voting contract deployed at ${contractAddress}`);
  } else {
    logger.info(`Current sequence is: ${ledgerState.sequence}`);
    logger.info(`Authority public key: x=${ledgerState.authority_pk.x}, y=${ledgerState.authority_pk.y}`);
    
    // Display proposal
    const proposal = ledgerState.proposal;
    logger.info(`Proposal: "${proposal.description}" (ID: ${proposal.id})`);
    logger.info(`Proposer: ${toHex(proposal.proposer).slice(0, 16)}...`);
    logger.info(`Deadline: ${new Date(Number(proposal.deadline_timestamp) * 1000).toISOString()}`);
    logger.info(`Status: ${proposal.executed === 0 ? 'ACTIVE' : proposal.executed === 1 ? 'REJECTED' : 'PASSED'}`);
    logger.info(`Votes - For: ${proposal.votes_for}, Against: ${proposal.votes_against}`);
    
    // Display votes
    const votes = Array.from(ledgerState.votes);
    logger.info(`Total votes cast: ${votes.length}`);
    
    if (votes.length > 0) {
      logger.info('Recent votes (newest first):');
      votes.slice(0, 5).forEach((vote, index) => {
        const voteType = vote.vote_type ? 'FOR' : 'AGAINST';
        logger.info(`  ${index + 1}. ${voteType} by ${toHex(vote.voter_hash).slice(0, 8)}...`);
      });
      
      if (votes.length > 5) {
        logger.info(`  ... and ${votes.length - 5} more votes`);
      }
    }
    
    // Display comments
    const comments = Array.from(ledgerState.comments);
    if (comments.length > 0) {
      logger.info(`Total comments: ${comments.length}`);
      logger.info('Recent comments (newest first):');
      comments.slice(0, 3).forEach((comment, index) => {
        logger.info(`  ${index + 1}. "${comment.comment}" by ${toHex(comment.commenter_hash).slice(0, 8)}...`);
      });
      
      if (comments.length > 3) {
        logger.info(`  ... and ${comments.length - 3} more comments`);
      }
    }
    
    // Display voter registry
    const voterCount = ledgerState.voter_registry.size();
    logger.info(`Total unique voters: ${voterCount}`);
  }
};

/* **********************************************************************
 * displayPrivateState: shows the hex-formatted value of the secret key.
 */

const displayPrivateState = async (providers: BBoardProviders, logger: Logger): Promise<void> => {
  const privateState = await providers.privateStateProvider.get(bboardPrivateStateKey);
  if (privateState === null) {
    logger.info(`There is no existing bulletin board private state`);
  } else {
    logger.info(`Current secret key is: ${toHex(privateState.secretKey)}`);
  }
};

/* **********************************************************************
 * displayDerivedState: shows the values of derived state which is made
 * by combining the ledger state with private state. In this example, the
 * derived state compares the owner's key with the private secret key to
 * determine if the current user is the owner of the current message.
 */

const displayDerivedState = (ledgerState: BBoardDerivedState | undefined, logger: Logger) => {
  if (ledgerState === undefined) {
    logger.info(`No voting contract state currently available`);
  } else {
    logger.info(`Current sequence is: ${ledgerState.sequence}`);
    logger.info(`Total votes: ${ledgerState.voteCount}`);
    logger.info(`Total comments: ${ledgerState.commentCount}`);
    logger.info(`Total voters: ${ledgerState.voterCount}`);
    logger.info(`You are ${ledgerState.isAuthority ? 'the authority' : 'not the authority'}`);
    
    // Display proposal information
    const proposal = ledgerState.proposal;
    logger.info(`Proposal: "${proposal.description}" (ID: ${proposal.id})`);
    logger.info(`Status: ${proposal.executed === 0 ? 'ACTIVE' : proposal.executed === 1 ? 'REJECTED' : 'PASSED'}`);
    logger.info(`Votes - For: ${proposal.votes_for}, Against: ${proposal.votes_against}`);
    logger.info(`Deadline: ${new Date(Number(proposal.deadline_timestamp) * 1000).toISOString()}`);
    
    if (ledgerState.votes.length > 0) {
      logger.info('Recent votes:');
      ledgerState.votes.slice(0, 3).forEach((vote, index) => {
        const voteType = vote.vote_type ? 'FOR' : 'AGAINST';
        logger.info(`  ${index + 1}. ${voteType} by ${toHex(vote.voter_hash).slice(0, 8)}...`);
      });
    } else {
      logger.info('No votes cast yet');
    }
    
    if (ledgerState.comments.length > 0) {
      logger.info('Recent comments:');
      ledgerState.comments.slice(0, 2).forEach((comment, index) => {
        logger.info(`  ${index + 1}. "${comment.comment}" by ${toHex(comment.commenter_hash).slice(0, 8)}...`);
      });
    }
  }
};

/* **********************************************************************
 * mainLoop: the main interactive menu of the voting contract CLI.
 * Before starting the loop, the user is prompted to deploy a new
 * contract or join an existing one.
 */

const MAIN_LOOP_QUESTION = `
You can do one of the following:
  1. Vote FOR the proposal (with automatic credential)
  2. Vote AGAINST the proposal (with automatic credential)
  3. Comment on the proposal (with automatic credential)
  4. Execute proposal (authority only)
  5. Display the current ledger state (known by everyone)
  6. Display the current private state (known only to this DApp instance)
  7. Display the current derived state (known only to this DApp instance)
  8. View all votes and comments
  9. Exit
Which would you like to do? `;

const mainLoop = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<void> => {
  const bboardApi = await deployOrJoin(providers, rli, logger);
  if (bboardApi === null) {
    return;
  }
  let currentState: BBoardDerivedState | undefined;
  const stateObserver = {
    next: (state: BBoardDerivedState) => (currentState = state),
  };
  const subscription = bboardApi.state$.subscribe(stateObserver);
  try {
    while (true) {
      const choice = await rli.question(MAIN_LOOP_QUESTION);
      switch (choice) {
        case '1': {
          const userIdentity = await rli.question(`Enter user identity (e.g., user@example.com): `);
          const livelinessInput = await rli.question(`Enter liveliness value (1-100, default 100): `);
          
          // Parse liveliness input with validation
          let liveliness = BigInt(100); // Default value
          if (livelinessInput.trim()) {
            const parsed = parseInt(livelinessInput.trim());
            if (isNaN(parsed) || parsed < 1 || parsed > 100) {
              logger.warn(`Invalid liveliness value "${livelinessInput}". Using default value 100.`);
            } else {
              liveliness = BigInt(parsed);
            }
          }
          
          logger.info(`‚úÖ Voting FOR proposal`);
          logger.info(`üë§ User identity: ${userIdentity}`);
          logger.info(`üíØ Liveliness: ${liveliness}`);
          
          try {
            logger.info(`üîê Creating authority credential for user...`);
            await bboardApi.authorizeAndVoteFor(userIdentity, liveliness);
            logger.info('‚úÖ Vote FOR submitted successfully!');
          } catch (error) {
            logger.error(`‚ùå Failed to vote FOR: ${error}`);
          }
          break;
        }
        case '2': {
          const userIdentity = await rli.question(`Enter user identity (e.g., user@example.com): `);
          const livelinessInput = await rli.question(`Enter liveliness value (1-100, default 100): `);
          
          // Parse liveliness input with validation
          let liveliness = BigInt(100); // Default value
          if (livelinessInput.trim()) {
            const parsed = parseInt(livelinessInput.trim());
            if (isNaN(parsed) || parsed < 1 || parsed > 100) {
              logger.warn(`Invalid liveliness value "${livelinessInput}". Using default value 100.`);
            } else {
              liveliness = BigInt(parsed);
            }
          }
          
          logger.info(`‚ùå Voting AGAINST proposal`);
          logger.info(`üë§ User identity: ${userIdentity}`);
          logger.info(`üíØ Liveliness: ${liveliness}`);
          
          try {
            logger.info(`üîê Creating authority credential for user...`);
            await bboardApi.authorizeAndVoteAgainst(userIdentity, liveliness);
            logger.info('‚úÖ Vote AGAINST submitted successfully!');
          } catch (error) {
            logger.error(`‚ùå Failed to vote AGAINST: ${error}`);
          }
          break;
        }
        case '3': {
          const userIdentity = await rli.question(`Enter user identity (e.g., user@example.com): `);
          const commentText = await rli.question(`Enter your comment: `);
          const livelinessInput = await rli.question(`Enter liveliness value (1-100, default 100): `);
          
          // Parse liveliness input with validation
          let liveliness = BigInt(100); // Default value
          if (livelinessInput.trim()) {
            const parsed = parseInt(livelinessInput.trim());
            if (isNaN(parsed) || parsed < 1 || parsed > 100) {
              logger.warn(`Invalid liveliness value "${livelinessInput}". Using default value 100.`);
            } else {
              liveliness = BigInt(parsed);
            }
          }
          
          logger.info(`üí¨ Commenting on proposal`);
          logger.info(`üë§ User identity: ${userIdentity}`);
          logger.info(`üìù Comment: "${commentText}"`);
          logger.info(`üíØ Liveliness: ${liveliness}`);
          
          try {
            logger.info(`üîê Creating authority credential for user...`);
            await bboardApi.authorizeAndComment(userIdentity, commentText, liveliness);
            logger.info('‚úÖ Comment submitted successfully!');
          } catch (error) {
            logger.error(`‚ùå Failed to comment: ${error}`);
          }
          break;
        }
        case '4': {
          logger.info(`‚öñÔ∏è Executing proposal (authority only)`);
          
          try {
            await bboardApi.executeProposal();
            logger.info('‚úÖ Proposal executed successfully!');
          } catch (error) {
            logger.error(`‚ùå Failed to execute proposal: ${error}`);
          }
          break;
        }
        case '5':
          await displayLedgerState(providers, bboardApi.deployedContract, logger);
          break;
        case '6':
          await displayPrivateState(providers, logger);
          break;
        case '7':
          displayDerivedState(currentState, logger);
          break;
        case '8': {
          const votes = bboardApi.getVotes();
          const comments = bboardApi.getComments();
          
          if (votes.length === 0 && comments.length === 0) {
            logger.info('No votes or comments yet');
          } else {
            if (votes.length > 0) {
              logger.info(`All votes (${votes.length} total):`);
              votes.forEach((vote, index) => {
                const voteType = vote.vote_type ? 'FOR' : 'AGAINST';
                logger.info(`${index + 1}. ${voteType} by ${toHex(vote.voter_hash).slice(0, 8)}... (Proposal: ${vote.proposal_id})`);
              });
            }
            
            if (comments.length > 0) {
              logger.info(`All comments (${comments.length} total):`);
              comments.forEach((comment, index) => {
                logger.info(`${index + 1}. "${comment.comment}" by ${toHex(comment.commenter_hash).slice(0, 8)}... (Proposal: ${comment.proposal_id})`);
              });
            }
          }
          break;
        }
        case '9':
          logger.info('Exiting...');
          return;
        default:
          logger.error(`Invalid choice: ${choice}`);
      }
    }
  } finally {
    // While we allow errors to bubble up to the 'run' function, we will always need to dispose of the state
    // subscription when we exit.
    subscription.unsubscribe();
  }
};

/* **********************************************************************
 * createWalletAndMidnightProvider: returns an object that
 * satifies both the WalletProvider and MidnightProvider
 * interfaces, both implemented in terms of the given wallet.
 */

const createWalletAndMidnightProvider = async (wallet: Wallet): Promise<WalletProvider & MidnightProvider> => {
  const state = await Rx.firstValueFrom(wallet.state());
  return {
    coinPublicKey: state.coinPublicKey,
    encryptionPublicKey: state.encryptionPublicKey,
    balanceTx(tx: UnbalancedTransaction, newCoins: CoinInfo[]): Promise<BalancedTransaction> {
      return wallet
        .balanceTransaction(
          ZswapTransaction.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()),
          newCoins,
        )
        .then((tx) => wallet.proveTransaction(tx))
        .then((zswapTx) => Transaction.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId()))
        .then(createBalancedTx);
    },
    submitTx(tx: BalancedTransaction): Promise<TransactionId> {
      return wallet.submitTransaction(tx);
    },
  };
};

/* **********************************************************************
 * waitForFunds: wait for tokens to appear in a wallet.
 *
 * This is an interesting example of watching the stream of states
 * coming from the pub-sub indexer.  It watches both
 *  1. how close the state is to present reality and
 *  2. the balance held by the wallet.
 */

const waitForFunds = (wallet: Wallet, logger: Logger) =>
  Rx.firstValueFrom(
    wallet.state().pipe(
      Rx.throttleTime(10_000),
      Rx.tap((state) => {
        const scanned = state.syncProgress?.synced ?? 0n;
        const behind = state.syncProgress?.lag.applyGap.toString() ?? 'unknown number';
        logger.info(`Wallet processed ${scanned} indices, remaining ${behind}`);
      }),
      Rx.filter((state) => {
        // Let's allow progress only if wallet is close enough
        const synced = typeof state.syncProgress?.synced === 'bigint' ? state.syncProgress.synced : 0n;
        const total = typeof state.syncProgress?.lag?.applyGap === 'bigint' ? state.syncProgress.lag.applyGap : 1_000n;
        return total - synced < 100n;
      }),
      Rx.map((s) => s.balances[nativeToken()] ?? 0n),
      Rx.filter((balance) => balance > 0n),
    ),
  );

/* **********************************************************************
 * buildWalletAndWaitForFunds: the main function that creates a wallet
 * and waits for tokens to appear in it.  The various "buildWallet"
 * functions all arrive here after collecting information for the
 * arguments.
 */

const buildWalletAndWaitForFunds = async (
  { indexer, indexerWS, node, proofServer }: Config,
  logger: Logger,
  seed: string,
): Promise<Wallet & Resource> => {
  const wallet = await WalletBuilder.buildFromSeed(
    indexer,
    indexerWS,
    proofServer,
    node,
    seed,
    getZswapNetworkId(),
    'warn',
  );
  wallet.start();
  const state = await Rx.firstValueFrom(wallet.state());
  logger.info(`Your wallet seed is: ${seed}`);
  logger.info(`Your wallet address is: ${state.address}`);
  let balance = state.balances[nativeToken()];
  if (balance === undefined || balance === 0n) {
    logger.info(`Your wallet balance is: 0`);
    logger.info(`Waiting to receive tokens...`);
    balance = await waitForFunds(wallet, logger);
  }
  logger.info(`Your wallet balance is: ${balance}`);
  return wallet;
};

// Generate a random see and create the wallet with that.
const buildFreshWallet = async (config: Config, logger: Logger): Promise<Wallet & Resource> =>
  await buildWalletAndWaitForFunds(config, logger, toHex(utils.randomBytes(32)));

// Prompt for a seed and create the wallet with that.
const buildWalletFromSeed = async (config: Config, rli: Interface, logger: Logger): Promise<Wallet & Resource> => {
  const seed = await rli.question('Enter your wallet seed: ');
  return await buildWalletAndWaitForFunds(config, logger, seed);
};

/* ***********************************************************************
 * This seed gives access to tokens minted in the genesis block of a local development node - only
 * used in standalone networks to build a wallet with initial funds.
 */
const GENESIS_MINT_WALLET_SEED = '0000000000000000000000000000000000000000000000000000000000000001';

/* **********************************************************************
 * buildWallet: unless running in a standalone (offline) mode,
 * prompt the user to tell us whether to create a new wallet
 * or recreate one from a prior seed.
 */

const WALLET_LOOP_QUESTION = `
You can do one of the following:
  1. Build a fresh wallet
  2. Build wallet from a seed
  3. Exit
Which would you like to do? `;

const buildWallet = async (config: Config, rli: Interface, logger: Logger): Promise<(Wallet & Resource) | null> => {
  if (config instanceof StandaloneConfig) {
    return await buildWalletAndWaitForFunds(config, logger, GENESIS_MINT_WALLET_SEED);
  }
  while (true) {
    const choice = await rli.question(WALLET_LOOP_QUESTION);
    switch (choice) {
      case '1':
        return await buildFreshWallet(config, logger);
      case '2':
        return await buildWalletFromSeed(config, rli, logger);
      case '3':
        logger.info('Exiting...');
        return null;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

const mapContainerPort = (env: StartedDockerComposeEnvironment, url: string, containerName: string) => {
  const mappedUrl = new URL(url);
  const container = env.getContainer(containerName);

  mappedUrl.port = String(container.getFirstMappedPort());

  return mappedUrl.toString().replace(/\/+$/, '');
};

/* **********************************************************************
 * run: the main entry point that starts the whole voting contract CLI.
 *
 * If called with a Docker environment argument, the application
 * will wait for Docker to be ready before doing anything else.
 */

export const run = async (config: Config, logger: Logger, dockerEnv?: DockerComposeEnvironment): Promise<void> => {
  const rli = createInterface({ input, output, terminal: true });
  let env;
  if (dockerEnv !== undefined) {
    env = await dockerEnv.up();

    if (config instanceof StandaloneConfig) {
      config.indexer = mapContainerPort(env, config.indexer, 'bboard-indexer');
      config.indexerWS = mapContainerPort(env, config.indexerWS, 'bboard-indexer');
      config.node = mapContainerPort(env, config.node, 'bboard-node');
      config.proofServer = mapContainerPort(env, config.proofServer, 'bboard-proof-server');
    }
  }
  const wallet = await buildWallet(config, rli, logger);
  try {
    if (wallet !== null) {
      const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
      const providers = {
        privateStateProvider: levelPrivateStateProvider<PrivateStateId>({
          privateStateStoreName: config.privateStateStoreName,
        }),
        publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
        zkConfigProvider: new NodeZkConfigProvider<BBoardCircuitKeys>(config.zkConfigPath),
        proofProvider: httpClientProofProvider(config.proofServer),
        walletProvider: walletAndMidnightProvider,
        midnightProvider: walletAndMidnightProvider,
      };
      await mainLoop(providers, rli, logger);
    }
  } catch (e) {
    logError(logger, e);
    logger.info('Exiting...');
  } finally {
    try {
      rli.close();
      rli.removeAllListeners();
    } catch (e) {
      logError(logger, e);
    } finally {
      try {
        if (wallet !== null) {
          await wallet.close();
        }
      } catch (e) {
        logError(logger, e);
      } finally {
        try {
          if (env !== undefined) {
            await env.down();
            logger.info('Goodbye');
            process.exit(0);
          }
        } catch (e) {
          logError(logger, e);
        }
      }
    }
  }
};

function logError(logger: Logger, e: unknown) {
  if (e instanceof Error) {
    logger.error(`Found error '${e.message}'`);
    logger.debug(`${e.stack}`);
  } else {
    logger.error(`Found error (unknown type)`);
  }
}
